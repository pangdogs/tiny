package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

func genEventTab(ctx *_CommandContext) {
	eventTabFile := ctx.EventTabDir

	if eventTabFile == "" {
		eventTabFile = strings.TrimSuffix(ctx.DeclFile, ".go") + "_eventtab_code.go"
	} else {
		eventTabFile = filepath.Dir(ctx.DeclFile) + string(filepath.Separator) + ctx.EventTabDir + string(filepath.Separator) + filepath.Base(strings.TrimSuffix(ctx.DeclFile, ".go")) + "_eventtab_code.go"
	}

	eventTabCode := &bytes.Buffer{}

	// 生成注释
	{
		fmt.Fprintf(eventTabCode, `// Code generated by %s%s; DO NOT EDIT.

package %s
	`, strings.TrimSuffix(filepath.Base(os.Args[0]), filepath.Ext(os.Args[0])),
			func() (args string) {
				for _, arg := range os.Args[1:] {
					if arg == "" {
						arg = `""`
					}
					args += " " + arg
				}
				return
			}(),
			ctx.EventTabPackage)
	}

	// 生成import
	{
		// 生成import
		{
			importCode := &bytes.Buffer{}

			fmt.Fprintf(importCode, "\nimport (")

			fmt.Fprintf(importCode, `
	%s "kit.golaxy.org/tiny/localevent"`, ctx.EventPackageAlias)

			fmt.Fprintf(importCode, `
	"kit.golaxy.org/tiny/util/container"`)

			fmt.Fprintf(importCode, "\n)\n")

			fmt.Fprintf(eventTabCode, importCode.String())
		}
	}

	// 解析事件定义
	eventDeclTab := _EventDeclTab{}
	eventDeclTab.Parse(ctx)

	// localevent包前缀
	localeventPrefix := ""
	if ctx.EventPackageAlias != "." {
		localeventPrefix = ctx.EventPackageAlias + "."
	}

	// 生成事件表接口
	{
		var eventsCode string

		for _, event := range eventDeclTab {
			eventsCode += fmt.Sprintf("\t%s() %sIEvent\n", event.Name, localeventPrefix)
		}

		fmt.Fprintf(eventTabCode, `
type I%[1]s interface {
%[2]s}
`, ctx.EventTabName, eventsCode)
	}

	// 生成事件表
	{
		var eventsRecursionCode string

		for i, event := range eventDeclTab {
			eventRecursion := ctx.EventTabDefEventRecursion

			switch eventRecursion {
			case "EventRecursion_Allow", "EventRecursion_Discard", "EventRecursion_Deepest", "EventRecursion_Disallow", "EventRecursion_NotEmit":
			default:
				eventRecursion = "EventRecursion_Discard"
			}

			if strings.Contains(event.Comment, "[EventRecursion_Allow]") {
				eventRecursion = "EventRecursion_Allow"
			} else if strings.Contains(event.Comment, "[EventRecursion_Discard]") {
				eventRecursion = "EventRecursion_Discard"
			} else if strings.Contains(event.Comment, "[EventRecursion_Deepest]") {
				eventRecursion = "EventRecursion_Deepest"
			} else if strings.Contains(event.Comment, "[EventRecursion_Disallow]") {
				eventRecursion = "EventRecursion_Disallow"
			} else if strings.Contains(event.Comment, "[EventRecursion_NotEmit]") {
				eventRecursion = "EventRecursion_NotEmit"
			}

			eventsRecursionCode += fmt.Sprintf("\t(*eventTab)[%d].Init(autoRecover, reportError, %s%s, hookAllocator, gcCollector)\n", i, localeventPrefix, eventRecursion)
		}

		var eventsAccessCode string

		for i, event := range eventDeclTab {
			eventsAccessCode += fmt.Sprintf(`
const %[2]sId int = %[4]d

func (eventTab *%[1]s) %[2]s() %[3]sIEvent {
	return &(*eventTab)[%[2]sId]
}
`, ctx.EventTabName, event.Name, localeventPrefix, i)
		}

		fmt.Fprintf(eventTabCode, `
type %[1]s [%[2]d]%[4]sEvent

func (eventTab *%[1]s) Init(autoRecover bool, reportError chan error, hookAllocator container.Allocator[%[4]sHook], gcCollector container.GCCollector) {
%[3]s}

func (eventTab *%[1]s) Get(id int) %[4]sIEvent {
	return &(*eventTab)[id]
}

func (eventTab *%[1]s) Open() {
	for i := range *eventTab {
		(*eventTab)[i].Open()
	}
}

func (eventTab *%[1]s) Close() {
	for i := range *eventTab {
		(*eventTab)[i].Close()
	}
}

func (eventTab *%[1]s) Clean() {
	for i := range *eventTab {
		(*eventTab)[i].Clean()
	}
}
%[5]s
`, ctx.EventTabName, len(eventDeclTab), eventsRecursionCode, localeventPrefix, eventsAccessCode)
	}

	fmt.Printf("EventTab: %s\n", ctx.EventTabName)

	os.MkdirAll(filepath.Dir(eventTabFile), os.ModePerm)

	if err := ioutil.WriteFile(eventTabFile, eventTabCode.Bytes(), os.ModePerm); err != nil {
		panic(err)
	}
}
