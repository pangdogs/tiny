package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"unicode"
)

func genEvent(ctx *CommandContext) {
	code := &bytes.Buffer{}

	// 生成注释
	{
		program := strings.TrimSuffix(filepath.Base(os.Args[0]), filepath.Ext(os.Args[0]))
		args := strings.Join(os.Args[1:], " ")

		fmt.Fprintf(code, `// Code generated by %s %s; DO NOT EDIT.

package %s
`, program, args, ctx.EventPackage)
	}

	// 生成import
	{
		importCode := &bytes.Buffer{}

		fmt.Fprintf(importCode, "\nimport (")

		fmt.Fprintf(importCode, `
	"fmt"
	%s "%s"
	%s "%s"`, ctx.PackageEventAlias, packageEventPath, ctx.PackageIfaceAlias, packageIfacePath)

		for _, imp := range ctx.FileAst.Imports {
			begin := ctx.FileSet.Position(imp.Pos())
			end := ctx.FileSet.Position(imp.End())

			impStr := string(ctx.FileData[begin.Offset:end.Offset])

			switch imp.Path.Value {
			case fmt.Sprintf(`"%s"`, packageEventPath):
				if imp.Name == nil {
					if ctx.PackageEventAlias == "event" {
						continue
					}
				} else {
					if imp.Name.Name == ctx.PackageEventAlias {
						continue
					}
				}
			case fmt.Sprintf(`"%s"`, packageIfacePath):
				if imp.Name == nil {
					if ctx.PackageIfaceAlias == "iface" {
						continue
					}
				} else {
					if imp.Name.Name == ctx.PackageIfaceAlias {
						continue
					}
				}
			}

			fmt.Fprintf(importCode, "\n\t%s", impStr)
		}

		fmt.Fprintf(importCode, "\n)\n")

		fmt.Fprintf(code, importCode.String())
	}

	// 解析事件定义
	eventDeclTab := EventDeclTab{}
	eventDeclTab.Parse(ctx)

	// event包前缀
	eventPrefix := ""
	if ctx.PackageEventAlias != "." {
		eventPrefix = ctx.PackageEventAlias + "."
	}

	// iface包前缀
	ifacePrefix := ""
	if ctx.PackageIfaceAlias != "." {
		ifacePrefix = ctx.PackageIfaceAlias + "."
	}

	// 生成事件发送代码
	for _, eventDecl := range eventDeclTab {
		// 是否导出事件发送代码
		exportEmitStr := "_Emit"
		if ctx.EventDefExport {
			exportEmitStr = "Emit"
		}

		if strings.Contains(eventDecl.Comment, "[EmitExport]") {
			exportEmitStr = "Emit"
		} else if strings.Contains(eventDecl.Comment, "[EmitUnExport]") {
			exportEmitStr = "_Emit"
		}

		auto := ctx.EventDefAuto

		if strings.Contains(eventDecl.Comment, "[EmitAuto]") {
			auto = true
		} else if strings.Contains(eventDecl.Comment, "[EmitManual]") {
			auto = false
		}

		var visibility string

		if unicode.IsLower(rune(eventDecl.Name[0])) {
			visibility = "_"
		}

		// 生成代码
		if auto {
			if eventDecl.FuncHasRet {
				fmt.Fprintf(code, `
type iAuto%[1]s interface {
	%[1]s() %[6]sIEvent
}

func Bind%[1]s(auto iAuto%[1]s, subscriber %[2]s%[8]s, priority ...int32) %[6]sHook {
	if auto == nil {
		panic(fmt.Errorf("%%w: %%w: auto is nil", %[6]sErrEvent, %[6]sErrArgs))
	}
	return %[6]sBind[%[2]s%[8]s](auto.%[1]s(), subscriber, priority...)
}

func %[9]s%[1]s%[7]s(auto iAuto%[1]s%[4]s) {
	if auto == nil {
		panic(fmt.Errorf("%%w: %%w: auto is nil", %[6]sErrEvent, %[6]sErrArgs))
	}
	%[6]sUnsafeEvent(auto.%[1]s()).Emit(func(subscriber %[10]sCache) bool {
		return %[10]sCache2Iface[%[2]s%[8]s](subscriber).%[3]s(%[5]s)
	})
}

func %[9]s%[1]s%[7]sWithInterrupt(auto iAuto%[1]s, interrupt func(%[11]s) bool%[4]s) {
	if auto == nil {
		panic(fmt.Errorf("%%w: %%w: auto is nil", %[6]sErrEvent, %[6]sErrArgs))
	}
	%[6]sUnsafeEvent(auto.%[1]s()).Emit(func(subscriber %[10]sCache) bool {
		if interrupt != nil {
			if interrupt(%[5]s) {
				return false
			}
		}
		return %[10]sCache2Iface[%[2]s%[8]s](subscriber).%[3]s(%[5]s)
	})
}
`, strings.Title(eventDecl.Name), eventDecl.Name, eventDecl.FuncName, eventDecl.FuncParamsDecl, eventDecl.FuncParams, eventPrefix, eventDecl.FuncTypeParamsDecl, eventDecl.FuncTypeParams, exportEmitStr, ifacePrefix, strings.TrimLeft(eventDecl.FuncParamsDecl, ", "))

			} else {
				fmt.Fprintf(code, `
type iAuto%[1]s interface {
	%[1]s() %[6]sIEvent
}

func Bind%[1]s(auto iAuto%[1]s, subscriber %[2]s%[8]s, priority ...int32) %[6]sHook {
	if auto == nil {
		panic(fmt.Errorf("%%w: %%w: auto is nil", %[6]sErrEvent, %[6]sErrArgs))
	}
	return %[6]sBind[%[2]s%[8]s](auto.%[1]s(), subscriber, priority...)
}

func %[9]s%[1]s%[7]s(auto iAuto%[1]s%[4]s) {
	if auto == nil {
		panic(fmt.Errorf("%%w: %%w: auto is nil", %[6]sErrEvent, %[6]sErrArgs))
	}
	%[6]sUnsafeEvent(auto.%[1]s()).Emit(func(subscriber %[10]sCache) bool {
		%[10]sCache2Iface[%[2]s%[8]s](subscriber).%[3]s(%[5]s)
		return true
	})
}

func %[9]s%[1]s%[7]sWithInterrupt(auto iAuto%[1]s, interrupt func(%[11]s) bool%[4]s) {
	if auto == nil {
		panic(fmt.Errorf("%%w: %%w: auto is nil", %[6]sErrEvent, %[6]sErrArgs))
	}
	%[6]sUnsafeEvent(auto.%[1]s()).Emit(func(subscriber %[10]sCache) bool {
		if interrupt != nil {
			if interrupt(%[5]s) {
				return false
			}
		}
		%[10]sCache2Iface[%[2]s%[8]s](subscriber).%[3]s(%[5]s)
		return true
	})
}
`, strings.Title(eventDecl.Name), eventDecl.Name, eventDecl.FuncName, eventDecl.FuncParamsDecl, eventDecl.FuncParams, eventPrefix, eventDecl.FuncTypeParamsDecl, eventDecl.FuncTypeParams, exportEmitStr, ifacePrefix, strings.TrimLeft(eventDecl.FuncParamsDecl, ", "))
			}
		} else {
			if eventDecl.FuncHasRet {
				fmt.Fprintf(code, `
func %[9]s%[1]s%[7]s(evt %[6]sIEvent%[4]s) {
	if evt == nil {
		panic(fmt.Errorf("%%w: %%w: evt is nil", %[6]sErrEvent, %[6]sErrArgs))
	}
	%[6]sUnsafeEvent(evt).Emit(func(subscriber %[10]sCache) bool {
		return %[10]sCache2Iface[%[2]s%[8]s](subscriber).%[3]s(%[5]s)
	})
}

func %[9]s%[1]s%[7]sWithInterrupt(evt %[6]sIEvent%[4]s, interrupt func(%[11]s) bool) {
	if evt == nil {
		panic(fmt.Errorf("%%w: %%w: evt is nil", %[6]sErrEvent, %[6]sErrArgs))
	}
	%[6]sUnsafeEvent(evt).Emit(func(subscriber %[10]sCache) bool {
		if interrupt != nil {
			if interrupt(%[5]s) {
				return false
			}
		}
		return %[10]sCache2Iface[%[2]s%[8]s](subscriber).%[3]s(%[5]s)
	})
}
`, strings.Title(eventDecl.Name), eventDecl.Name, eventDecl.FuncName, eventDecl.FuncParamsDecl, eventDecl.FuncParams, eventPrefix, eventDecl.FuncTypeParamsDecl, eventDecl.FuncTypeParams, exportEmitStr, ifacePrefix, strings.TrimLeft(eventDecl.FuncParamsDecl, ", "))

			} else {
				fmt.Fprintf(code, `
func %[9]s%[1]s%[7]s(evt %[6]sIEvent%[4]s) {
	if evt == nil {
		panic(fmt.Errorf("%%w: %%w: evt is nil", %[6]sErrEvent, %[6]sErrArgs))
	}
	%[6]sUnsafeEvent(evt).Emit(func(subscriber %[10]sCache) bool {
		%[10]sCache2Iface[%[2]s%[8]s](subscriber).%[3]s(%[5]s)
		return true
	})
}

func %[9]s%[1]s%[7]sWithInterrupt(evt %[6]sIEvent%[4]s, interrupt func(%[11]s) bool) {
	if evt == nil {
		panic(fmt.Errorf("%%w: %%w: evt is nil", %[6]sErrEvent, %[6]sErrArgs))
	}
	%[6]sUnsafeEvent(evt).Emit(func(subscriber %[10]sCache) bool {
		if interrupt != nil {
			if interrupt(%[5]s) {
				return false
			}
		}
		%[10]sCache2Iface[%[2]s%[8]s](subscriber).%[3]s(%[5]s)
		return true
	})
}
`, strings.Title(eventDecl.Name), eventDecl.Name, eventDecl.FuncName, eventDecl.FuncParamsDecl, eventDecl.FuncParams, eventPrefix, eventDecl.FuncTypeParamsDecl, eventDecl.FuncTypeParams, exportEmitStr, ifacePrefix, strings.TrimLeft(eventDecl.FuncParamsDecl, ", "))
			}
		}

		if eventDecl.FuncHasRet {
			fmt.Fprintf(code, `
func %[5]sHandle%[1]s(fun func(%[3]s) bool) %[5]s%[1]sHandler {
	return %[1]sHandler(fun)
}

type %[5]s%[1]sHandler func(%[3]s) bool

func (h %[5]s%[1]sHandler) %[2]s(%[3]s) bool {
	return h(%[4]s)
}
`, strings.Title(eventDecl.Name), eventDecl.FuncName, strings.TrimLeft(eventDecl.FuncParamsDecl, ", "), eventDecl.FuncParams, visibility)
		} else {
			fmt.Fprintf(code, `
func %[5]sHandle%[1]s(fun func(%[3]s)) %[5]s%[1]sHandler {
	return %[5]s%[1]sHandler(fun)
}

type %[5]s%[1]sHandler func(%[3]s)

func (h %[5]s%[1]sHandler) %[2]s(%[3]s) {
	h(%[4]s)
}
`, strings.Title(eventDecl.Name), eventDecl.FuncName, strings.TrimLeft(eventDecl.FuncParamsDecl, ", "), eventDecl.FuncParams, visibility)
		}

		fmt.Printf("Emit: %s\n", eventDecl.Name)
	}

	// 目标文件
	targetFile := filepath.Join(filepath.Dir(ctx.DeclFile), ctx.EventDir, filepath.Base(strings.TrimSuffix(ctx.DeclFile, ".go"))+"_code.go")

	os.MkdirAll(filepath.Dir(targetFile), os.ModePerm)

	if err := ioutil.WriteFile(targetFile, code.Bytes(), os.ModePerm); err != nil {
		panic(err)
	}
}
